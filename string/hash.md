# 字符串哈希

## 定义

我们定义一个把字符串映射到整数的函数 $f$，这个 $f$ 称为 Hash 函数。

我们希望这个函数 $f$ 可以方便地帮我们判断两个字符串是否相等。

## Hash 的思想

Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。

```ad-warning
这里的「值域较小」在不同情况下意义不同。
在 [哈希表](../data_structure/hash.md) 中，值域需要小到能够接受线性的空间与时间复杂度。
在字符串哈希中，值域需要小到能够快速比较（$10^9$、$10^{18}$ 都是可以快速比较的）。
同时，为了降低哈希冲突率，值域也不能太小。
```

具体来说，哈希函数最重要的性质可以概括为下面两条：

1. 在 Hash 函数值不一样的时候，两个字符串一定不一样；
2. 在 Hash 函数值一样的时候，两个字符串不一定一样（但应该大概率一样）。

我们将 Hash 函数值一样但原字符串不一样的现象称为**哈希碰撞**。

## 解释

我们需要关注的是 **时间复杂度**和 Hash 的**准确率**。

通常我们采用的是多项式 Hash 的方法，对于一个长度为 $l$ 的字符串 $s$ 来说，我们定义如下多项式 Hash 函数：

$$
f(s) = \sum_{i=1}^{l} s[i] \times b^{l-i} \pmod M
$$

例如，对于字符串 $xyz$，其哈希函数值为 $xb^2+yb+z$。

特别要说明的是，也有很多人使用的是另一种 Hash 函数的定义，即 

$$
f(s) = \sum_{i=1}^{l} s[i] \times b^{i-1} \pmod M
$$

这种定义下，同样的字符串 $xyz$ 的哈希值就变为了 $x+yb+zb^2$ 了。

显然，上面这两种哈希函数的定义函数都是可行的，但二者在之后会讲到的计算子串哈希值时所用的计算式是不同的，因此千万注意 **不要弄混了这两种不同的 Hash 方式**。

由于前者的 Hash 定义计算更简便、使用人数更多、且可以类比为一个 $b$ 进制数来帮助理解，所以本文下面所将要讨论的都是使用 $f(s) = \sum_{i=1}^{l} s[i] \times b^{l-i} \pmod M$ 来定义的 Hash 函数。

下面讲一下如何选择 $M$ 和计算哈希碰撞的概率。

这里 $M$ 需要选择一个素数（至少要比最大的字符要大），$b$ 可以任意选择。

如果我们用未知数 $x$ 替代 $b$，那么 $f(s)$ 实际上是多项式环 $\mathbb{Z}_M[x]$ 上的一个多项式。考虑两个不同的字符串 $s,t$，有 $f(s)=f(t)$。我们记 $h(x)=f(s)-f(t)=\sum_{i=1}^l(s[i]-t[i])x^{l-i}\pmod M$，其中 $l=\max(|s|,|t|)$。可以发现 $h(x)$ 是一个 $l-1$ 阶的非零多项式。

如果 $s$ 与 $t$ 在 $x=b$ 的情况下哈希碰撞，则 $b$ 是 $h(x)$ 的一个根。由于 $h(x)$ 在 $\mathbb{Z}_M$ 是一个域（等价于 M 是一个素数，这也是为什么 M 要选择素数的原因）的时候，最多有 l-1 个根，如果我们保证 b 是从 [0,M) 之间均匀随机选取的，那么 f(s) 与 f(t) 碰撞的概率可以估计为 
 
\frac{l-1}{M}。简单验算一下，可以发现如果两个字符串长度都是 1 的时候，哈希碰撞的概率为 
 
\frac{1-1}{M}=0，此时不可能发生碰撞。

## 参考

- https://oi-wiki.org/string/hash/
# 最短路径

- [最短路径](#最短路径)
  - [简介](#简介)
  - [无向无权图的路径](#无向无权图的路径)
  - [有向无权图的路径](#有向无权图的路径)
  - [3. 有权图的路径](#3-有权图的路径)

2024-08-19

## 简介

对 weighted-graph，每条边 $(v_i, v_j)$ 对应成本 $c_{i,j}$。路径 $v_1v_2\cdots v_N$ 的成本为 $\sum_{i=1}^{N-1}c_{i,i+1}$，称为 **weighted-path-length**。对 unweighted-path-length 就是 path 包含的 edges 数，即 $N-1$。如下所示，从 v3 到 v5 的最短加强路径长度为 7：

<img src="./images/image-20240819144843856.png" alt="image-20240819144843856" style="zoom: 25%;" />

最短路径问题：在 graph 中找到从起点到终点的最短路径。

**单源最短路径问题**（single-source）

<img src="./images/image-20240819145015329.png" alt="image-20240819145015329" style="zoom: 25%;" />

上图：找到从 v3 出发到所有其它节点的最短路径。

单源最短路径的目标是获得下表：

<img src="./images/image-20240819145145174.png" alt="image-20240819145145174" style="zoom: 25%;" />

表中包含从 v3 出发到其它节点的最短路径：

- vertex 表示路径终点
- dist 为最短路径长度
- path 为路径

例如，查看从 v3 到 v2 的最短路径：

- 看表中第二行，path 为 v1；
- 表示 v2 的前一个节点是 v1；
- 查看如何从起点到 v1，查看第一行，path 为 v3，表示 v1 的前一个节点是 v3；
- 这样就获得从 v3 到 v3 的最短路径为 v3->v1->v2。

如果 edge 的 cost 为负数，例如：

<img src="./images/image-20241124145218743.png" alt="image-20241124145218743" style="zoom: 33%;" />

从 v5 到 v4 的 cost 为 1，但是如果沿着 v4,v4,v2,v5,v4 循环一次，cost 为-5，继续循环，cost 会一直降低，因此，从 v5 到 v4 的最短加权路径是不确定的，这个循环称为**负成本循环（negative-cost cycle）**。当 graph 中存在负成本循环，就无法确定最短路径。下面讨论没有负成本循环的情况。

最短路径问题有许多应用场景，如 vertex 代表计算机，edge 代表计算机之间的链接，cost 代表通信成本或延迟等，那么就可以使用最短路径算法找到从一台计算机发送信息到另一个计算机的最便宜的方法。

下面介绍最短路径的四个版本：

1. unweight-graph 的最短路径，最佳算法 $O(|E|+|V|)$
2. weighted-graph 的最短路径，假设没有负边，使用合理的数据结构，该算法能达到 $O(|E|\log|V|)$
3. 如果有负边，提供一个简单解决方案，但其时间复杂度很差，为 $O(|E|\cdot |V|)$
4. 最后，为无环 weighted-graph 提供一个线性时间解决方案

***

## 无向无权图的路径

路径定义：

<img src="./images/image-20240819143648946.png" alt="image-20240819143648946" style="zoom: 25%;" />

路径长度定义：

<img src="./images/image-20240819143909296.png" alt="image-20240819143909296" style="zoom: 25%;" />

如果是有权图，则需要考虑边的权重。

**简单路径（simple-path）**

<img src="./images/image-20240819144101536.png" alt="image-20240819144101536" style="zoom: 25%;" />

简单路径：路径上没有重复节点。

上图不是一个简单路径（路径中 v4 出现两次）。

<img src="./images/image-20240819144212264.png" alt="image-20240819144212264" style="zoom: 25%;" />

两个节点之间未必存在路径，如 v1 到 v5 不存在路径。

## 有向无权图的路径

<img src="./images/image-20240819144321807.png" alt="image-20240819144321807" style="zoom: 25%;" />

有向图的路径只有一个方向。从 v3 可以到 v5，但是从 v5 无法返回 v3。

**有向无权图**的路径长度：路径包含**边**的个数。上图中从 v3 到 v5 的路径长度为 3.

有向无权图的单源最短路径问题，是加权最短路径问题的一个特例，因为我们可以为边分配权重 1.

现在，假设我们只对最短路径的长度感兴趣。以下图为例：

<img src="./images/image-20241124171754841.png" alt="image-20241124171754841" style="zoom: 50%;" />

v3 设为起点 s，从 s 到 v3 的最短路径长度为 0。然后查找所有距离 s 为 1 的顶点，可以通过查看与 s 相邻的顶点来查找这些顶点。采用该方式，可以发现 v1 和 v6 和 s 的距离为 1。如下图：

<img src="./images/image-20241124172342081.png" alt="image-20241124172342081" style="zoom:50%;" />

然后查找与 v1 和 v6 相邻但未确定距离的顶点，它们的距离为 2。得到 v2 和 v4 的距离为 2：

<img src="./images/image-20241124172319761.png" alt="image-20241124172319761" style="zoom:50%;" />

最后检查 v2 和 v4 的相邻顶点，得到 v5 和 v7 的最短路径长度为 3。到此，所有顶点计算完毕。结果如下：

<img src="./images/image-20241124172830734.png" alt="image-20241124172830734" style="zoom:50%;" />

这种搜索图的策略称为**广度优先搜索**（breadth-first search, BFS）。它分层处理定点：最接近起点的顶点先处理，最远的顶点最后处理。这与树的分层遍历非常相似。

广度优先搜索的代码实现，首先初始化配置：

| v    | known | dv   | pv   |
| ---- | ----- | ---- | ---- |
| v1   | F     | ∞    | 0    |
| v2   | F     | ∞    | 0    |
| v3   | F     | 0    | 0    |
| v4   | F     | ∞    | 0    |
| v5   | F     | ∞    | 0    |
| v6   | F     | ∞    | 0    |
| v7   | F     | ∞    | 0    |



## 3. 有权图的路径

有权图对路径长度的定义有所不同：

<img src="./images/image-20240819144617624.png" alt="image-20240819144617624" style="zoom: 25%;" />

<img src="./images/image-20240819144659825.png" alt="image-20240819144659825" style="zoom: 25%;" />

有向图的路径更容易不存在。
